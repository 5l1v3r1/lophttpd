lonely & poor HTTPD
===================

lophttpd was written to demonstrate (to myself) that it is possible
to have a webserver running in a single thread and handling multiple
connections at the same time. The ammount of connections is only limited by the
maximum number of open files per process (65k) and by your CPU/network
speed.

Scheduling of connections is done in user-space by lophttpd. It uses
sendfile(2) call to get a good download performance.

Features:

+ runs as unprived user in a chroot
+ does not require syslogd
+ only handles static content (e.g. no CGI scripts etc)
+ runs in a single process (lonely)
+ integrated auto indexing support
+ integrated vhost support

You should run lophttpd as root. Then it chroots itself to the
"-R" parameter given on the commandline and drops the privileges
to that of the user given via "-u". It runs on port "-p".
If you add "-i" to the commandline, it generates an index file
(in memory) for the web-root recursively. The user specified via -u
must have the permissions to walk the webroot, otherwise
you will get wrong results.
"-H" enables vhosts.

For every vhost you need to create a subdir of name

 vhost<vhost-name>[:vhost-port]

If port is 80 it should be omitted. For example if you
have a vhost 127.0.0.1:8080 and your webroot is /srv/www/htdocs
and you want to use autoindexing, create the subdir

 vhost127.0.0.1:8080

in /srv/www/htdocs and run

 # ./lhttpd -R /srv/www/htdocs -i -H -p 8080

Users can browse "127.0.0.1:8080" then. Whatever they type in the address field
of their browser can be appended to "vhost" and created as a subdir.
lophttpd will serve this as a vhost as long as your DNS resolves
to the IP address where lophttpd is running.

Default log-location is /var/log/lophttpd. If you change this, take care
that your logfile is located outside the chroot cage.

You can run lophttpd as normal user on a port >= 1024, but this is INSECURE!
It does not drop privs/chroot then. The aim is to quickly exchange some
ISO's or tarballs in a separated, secure LAN between friends.

If you change something in the webroot while lophttpd is running,
e.g. you use autoindexing and copy new files to webroot or
delete files from there, you need to tell lophttpd by sending
it a SIGUSR1 signal. It will drop its open file caches and
generates new indexes.

lophttpd (remember the "poor") only implements a (small) subset of
HTTP 1.1 RFC. The only reason for it to exist was the fun to write
it, the challenge to do it in a single process as well as the challenge
to have it (if possible) faster than any other httpd.

If lhttpd experiances that the generated indexes exceed a certain limit,
(default 10,000 bytes per dir) it writes the appropriate index.html to disk
inside the directory. It wont overwrite exising files. But creation of
large index files makes sense, otherwise it would need to keep 100's
of MB inside RAM. Since lhttpd is walking the webroot as root when
generating the index, take care that users dont create large FS-trees
so that lhttpd is forced to generate junk.
Generating indexes for large directories, containing 100k of files, can
take some time.

Since version 0.82 lophttpd contains an experimental feature to
speed up logging. Since writing 1000's of logs per second can
be a bottleneck, lophttpd introduces different log providers
which you can choose via -L.
By default it is "file" which means the normal behavior. You can
also say "mmap". Then it is using a mmap-backed buffer which speeds
up logging. "aio" is also spupported which uses the POSIX realtime
aio_ calls. However this could lead to drops of messages if
under very heavy load. Remember that lophttpd is still single threaded,
even with different log providers. (For aio to be really
single threaded you may want to check out my Linux aio implementation
since glibc is using pthreads under the hood.)

Since version 0.86 lophttpd supports multicore setups for Linux.
If run without any -n switch, lophttpd will run one process per core.
You can turn this off by using "-n 1" or you specify the number
of cores you want lophttpd to use.

Since version 0.88 lophttpd has one logfile per core. If you run on two
cores you get "logfile.0" and "logfile.1". This way we avoid file locking.
lophttpd is now also using localtime instead of gmtime in the logs,
so take care to have the right TZ environment variable set when starting
lhttpd or it will use UTC.

If you use multicore support, every process will have its own cache
for open files and stats. Do not run lhttpd on large read-only directories w/o
index.html and autoindexing since it needs to keep a big cache about
indexing information in memory then (per core!). This does not happen
if the directory is writable since lophttpd will dump content into a
index.html file if above a certain threshold.

If you have ideas and or offer performance/testing environment please
drop me an email: sebastian.krahmer [at] gmail [dot] com :-)

